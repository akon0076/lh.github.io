---
layout:     post
title:      "渲染模式-介绍（译）"
subtitle:   "从SG到CSR"
date:       2023-01-08 23:00:00
author:     "LH"
catalog:    false
no-catalog: true
published:  true
header-style: text
tags:
  # - 被夹
---

# 介绍

当你开始构建新的 Web 应用程序时，你需要做出的基本决策之一是:我想「如何」以及在「何处」渲染内容？它应该在 Web 服务器、构建服务器、边缘计算服务器上还是直接在客户端上渲染？应该一次性全部渲染、部分渲染还是渐进渲染？

这些关键决策的答案在很大程度上取决于你的场景。
择最合适的渲染模式可以使你为工程团队创建的开发人员体验 (Developer Experience——DX) 和你为最终用户设计的用户体验 (User Experience——UX) 产生天壤之别。

选择正确的模式可以以较低的处理成本实现更快的构建和出色的加载性能。另一方面，错误的模式选择可能会扼杀一个应用程序，而这个应用程序本可以将一个伟大的商业创意变为现实。因此，你必须确保你拥有的每一个革命性想法都以适当的渲染模式进行开发。

<img src="/img/patterns/2.1.png" loading=lazy>

# 渲染模式的重要性

为了创造出色的用户体验，我们通常会尝试针对以用户为中心的指标优化我们的应用程序，比如[Web核心指标(Core Web Vitals——CWV)](https://web.dev/vitals/)，CWV 指标测量与用户体验最相关的参数。优化 CWV 有助于确保我们的应用程序展现出色的用户体验和最佳 SEO。

<img src="/img/patterns/2.2.png" loading=lazy>

为了为我们的产品/工程团队创建出色的开发体验，我们必须通过确保更快的构建时间、轻松的回滚、可扩展的基础设施以及许多其他有助于开发人员成功的功能来优化我们的开发环境。

基于这些原则设置的开发环境，使我们的开发团队能够高效地构建出色的产品。

总结我们的期望，我们现在已经列了一个很长的清单。但是，如果你选择了正确的渲染模式，你可以开箱即用地获得其中的大部分好处。

<img src="/img/patterns/2.3.png" loading=lazy>

# 选择一个模式

渲染模式已经走过了漫长的道路，从服务器端渲染 (SSR) 和客户端渲染 (CSR) ，到今天在不同论坛上讨论和判断的仅有细微差别的模式。虽然这可能会让人不知所措，但请务必记住，每种模式都是为解决特定场景而设计的。对一个场景有利的模式特征可能对另一个场景有害。不同类型的页面也很可能需要在同一网站上使用不同的渲染模式。

Chrome 团队[鼓励](https://web.dev/rendering-on-the-web/)开发人员考虑静态或服务器端渲染，而不是完全重新[注水](https://zhuanlan.zhihu.com/p/323174003)的方法。随着时间的推移，默认情况下，渐进式加载和渲染技术可能有助于在使用现代框架时，在性能和功能交付之间取得良好的平衡。

以下章节详细介绍了不同的模式——新的/旧的模式。但首先，我们将简要介绍其中的一些，以帮助你了解它们在哪些方面最有效。

# 静态渲染

静态渲染是一种简单而强大的模式，你可以使用它来构建具有几乎即时页面加载的快速网站。

使用静态渲染，整个页面的 HTML 在构建时生成，并且在下一次构建之前不会更改。HTML 内容是静态的，可轻松缓存在 CDN 或边缘网络上。当用户请求特定页面时，CDN 可以快速将预渲染的缓存 HTML 提供给用户。这大大减少了在典型的SSR处理请求、渲染 HTML 内容和响应请求所需的时间。

上面描述的过程最适合那些不经常变化，并且无论谁请求都显示相同数据的页面。由于我们今天在网络上使用大量动态的、自定义的数据，因此我们有多种静态渲染模式来满足不同的场景。

<img src="/img/patterns/2.4.png" loading=lazy>

# 基本/普通静态渲染

由于静态渲染有多种变体，我们将之前讨论的主要技术称为纯静态渲染。你可以将它用于几乎没有或没有动态内容的页面。

以下房地产网站演示中的页面始终向全球所有人显示相同的内容。它不包含任何动态数据或个性化内容。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_10.10.58_AM_umtlyl.webm"></video>

当部署和构建站点时（例如，在 Vercel 上），会生成相应的 HTML 并保存在服务器上的静态存储中。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_10.18.37_AM_bhybvb.webm"></video>

用户请求页面时，服务器将预先生成的 HTML 发送给客户端。此响应也会缓存到离用户最近的边缘服务器上。然后浏览器渲染 HTML 并使用 JavaScript 包来给页面注水。

<img src="/img/patterns/2.5.png" loading=lazy>

纯静态渲染性能非常好，它有非常快的 [TTFB](https://web.dev/ttfb/)，因为 HTML 已经在服务器上可用。浏览器接收到更快的响应并可以快速渲染它，从而产生快速的 [FCP](https://web.dev/fcp/) 和 [LCP](https://web.dev/lcp/)。由于内容是静态的，因此在渲染时不会发生布局偏移。

<img src="/img/patterns/2.6.png" loading=lazy>

因此，纯静态渲染，尤其是使用 CDN 进行缓存，有助于实现出色的 Web 核心指标。然而，大多数网站至少有一些动态内容或用户交互。

# 静态渲染+客户端 fetch

假设我们想要增强我们的房地产示例以显示最新的房产清单。我们必须使用数据提供者（data provider）来获取这些列表。

<img src="/img/patterns/2.7.png" loading=lazy>

在这种情况下，我们可以将「静态渲染」与「客户端 fetch」 结合使用。当你希望根据每个请求更新数据时，这种模式非常有用。

你仍然可以为网站使用静态渲染，在要放置动态列表数据的位置渲染具有骨架组件的 UI。然后，在页面加载后，我们可以在客户端获取数据（例如使用 SWR）。

<img src="/img/patterns/2.9.png" loading=lazy>

自定义 API 路由用于从 CMS（内容管理系统） 获取数据并返回此数据。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_2.55.30_PM_r0jvez.webm"></video>

当用户请求页面时，预先生成的 HTML 文件被发送到客户端。用户最初看到的是没有任何数据的框架 UI。客户端从 API 路由获取数据、接收响应并显示列表。（示例中不包括水化调用）响应并显示列表。 （示例中不包括注水）

<img src="/img/patterns/2.10.png" loading=lazy>

虽然使用客户端获取的静态渲染为我们提供了良好的 TTFB 和 FCP，但 LCP 不是最佳选择，因为“最大内容”只能在我们从 API 路由获取列表数据后显示。

<img src="/img/patterns/2.11.png" loading=lazy>

布局偏移的可能性也很大，特别是如果框架 UI 的大小与最终渲染的内容不匹配时。

另一个缺点是这种方法可能会导致更高的服务器成本，因为我们为每个页面请求调用一次 API 路由。

Next.js 提供了一些解决方案，如以下部分所述，可在处理动态数据时提高应用程序的性能。

# 静态 + getStaticProps

<img src="/img/patterns/2.12.png" loading=lazy>

此方法允许你在构建时访问数据提供程序并在服务器上获取数据。
如果你知道静态页面上的动态数据在构建时始终可用，那么这可能是一个很好的解决方案。

<img src="/img/patterns/2.13.png" loading=lazy>

getStaticProps 方法允许我们使用服务器上的数据生成 HTML。因此，我们可以避免创建 API 路由来获取客户端上的数据。同样地，加载数据时不需要骨架组件，因为页面将与数据一起渲染。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.02.04_PM_avmzuy.webm"></video>

当我们构建项目时，将调用数据提供程序，并将返回的数据通过管道传输到生成的 HTML。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.06.26_PM_djvt57.webm"></video>

当用户请求页面时，这个过程类似于普通的静态渲染。响应被缓存并渲染到屏幕上，浏览器获取页面所需的 JavaScript 包。

<img src="/img/patterns/2.14.png" loading=lazy>

从客户端的角度来看，网络和主线程的工作与普通静态渲染相同，因此我们获得了类似的卓越性能。

<img src="/img/patterns/2.15.png" loading=lazy>

随着站点的增长，DX 在使用这种方法时可能不太好。

对于具有数百个静态构建页面的站点（例如，博客站点），重复调用 getStaticProps 方法会导致构建时间过长。如果你使用的是外部 API，你可能会达到请求限制或产生大量使用费。

该方法也仅适用于我们可以在构建时不经常更新数据的情况。频繁更新数据意味着经常需要重建和重新部署站点。

# 增量静态生成（Incremental Static Regeneration——ISR）

<img src="/img/patterns/2.16.png" loading=lazy>

我们可以使用增量静态再生来解决构建时间，以及前面讨论的动态数据问题。

ISR 是混合的渲染的，因为它允许我们仅预渲染某些静态页面，并在用户请求时按需渲染动态页面。这会缩短构建时间，并允许在特定时间间隔后自动使缓存失效并重新生成页面。

<img src="/img/patterns/2.17.png" loading=lazy>

假设我们现在想要显示单个属性的详细信息以增强我们之前的演示。我们可以预渲染这些新页面，以便在用户单击列表时快速加载它们。

<img src="/img/patterns/2.18.png" loading=lazy>

Next.js 通过使用 getStaticPaths 方法生成动态路径来帮助我们实现这一点。我们可以告诉 Next.js 根据查询参数预先生成哪些页面。

对于我们的演示，让我们获取所有列表并为每个列表预先生成页面。请注意，如果有数千个列表，这将花费很长时间。在这种情况下，我们将不得不告诉 Next 只预先生成所有页面的一个子集，并在剩余列表页面按需生成时（当用户请求时）渲染回退

<img src="/img/patterns/2.19.png" loading=lazy>

预渲染和按需生成页面的交付方式类似。如果用户请求尚未生成的页面，它会按需生成并由边缘服务器缓存。因此，只有第一个用户可能对未预渲染的页面有较差的体验。其他所有人都将受益于快速的缓存响应。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_3.49.59_PM_deygni.webm"></video>

这解决了前面的方法的构建时间长的问题。但是我们仍然有列表页，所以每次我们有新列表时都需要重新部署。

<img src="/img/patterns/2.20.png" loading=lazy>

要启用列表页的刷新，我们可以自动使缓存失效并以特定时间间隔在后台重新生成页面。我们可以通过向返回的对象添加一个重新验证字段来使用它。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/updated_jvhqnv.webm"></video>

如果用户请求的页面在缓存中的时间超过了指定的秒数，则用户最初会看到旧的页面。同时触发页面重新生成。一旦页面在后台重新生成，缓存就会失效并使用最近重新生成的页面进行更新。

<img src="/img/patterns/2.21.png" loading=lazy>

使用增量静态重新生成，我们可以通过每隔几秒自动重新验证页面来显示动态内容。

虽然这已经比我们之前的有了很大的改进，但也有一些缺点。我们的内容可能不会像我们定义的间隔那样频繁更新。这将导致不必要的页面重新生成和缓存失效。每次发生这种情况时，我们都会调用我们的serverless function，这可能会导致更高的服务器成本。

# 按需增量静态生成（On-demand Incremental Static Regeneration）

<img src="/img/patterns/2.22.png" loading=lazy>

为了解决上面提到的最后一个缺点，我们有按需增量静态再生，它允许我们使用 ISR，但再生发生在某些事件上，而不是固定的时间间隔。

<img src="/img/patterns/2.23.png" loading=lazy>

我们不使用重新验证字段，而是根据 API 路由中的新数据重新验证。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.24.13_PM_xeumhu.webm"></video>

例如，我们可以监听一个传入的 [webhook](https://zhuanlan.zhihu.com/p/133449879) 事件，它告诉我们新数据何时被添加到我们的数据提供者。当我们调用 revalidate 方法时，指定路径的页面会自动重新生成。使用常规 ISR，更新后的页面仅缓存在已处理用户页面请求的边缘节点上。按需 ISR 通过边缘网络重新生成和重新分发页面，以便全球用户将自动从边缘缓存中看到最新版本的页面，而不会看到陈旧的内容。我们还避免了不必要的重新生成和无服务器函数调用，与常规 ISR 相比降低了运营成本。

<img src="/img/patterns/2.24.png" loading=lazy>

因此，按需 ISR 为我们提供了性能优势和出色的 DX。

总体而言，静态生成是一种奇妙的模式，其变体，尤其是 ISR，可以涵盖各种场景。

它使我们能够以合理的成本拥有始终在线的快速动态网站。但是，在某些场景中，静态并不是最佳选择，例如，对于每个用户都不同的高度动态、个性化的页面。让我们看看哪种模式最适合这些。

# 服务端渲染

<img src="/img/patterns/2.25.png" loading=lazy>

通过服务器端渲染，我们为每个请求生成 HTML。这种方法最适合包含高度个性化数据的页面，例如，基于用户 cookie 的数据或通常从用户请求中获得的任何数据。它也适用于应该阻止渲染的页面，可能基于身份验证状态。

<img src="/img/patterns/2.26.png" loading=lazy>

个性化仪表板是页面上高度动态内容的一个很好的例子。大部分内容基于用户身份或授权级别，可能包含在用户 cookie 中。此仪表板仅在用户通过身份验证时显示，并且可能显示其他人不应看到的特定于用户的敏感数据。

<img src="/img/patterns/2.27.png" loading=lazy>

Next.js 允许我们使用 getServerSideProps 方法在服务器上渲染页面。此方法针对每个请求在服务器上运行，并最终将返回的数据传递给页面以生成 HTML。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.31.41_PM_oxsq12.webm"></video>

当用户请求页面时，getServerSideProps 方法运行，返回用于生成页面的数据，并将响应发送给客户端。然后，客户端渲染此 HTML 并可能发送另一个请求来获取 JavaScript 包，该包对元素进行注水。

生成的 HTML 内容对于每个请求都是唯一的，不应由 CDN 缓存。

<img src="/img/patterns/2.28.png" loading=lazy>

客户端的网络和主线程对于静态和服务器端渲染非常相似。FCP 几乎等同于 LCP，我们可以轻松避免布局偏移，因为初始页面加载后没有动态内容加载。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.36.49_PM_kkuxv3.webm"></video>

但是，服务器渲染页面的 TTFB 比静态渲染页面要长得多，因为页面是在每次请求时从头开始生成的。

<img src="/img/patterns/2.29.png" loading=lazy>

虽然当你想要渲染高度个性化的数据时，服务器渲染是一种极好的方法，但要获得出色的用户体验并降低服务器成本，还需要考虑一些事项。这些事项的成本可能很高，因为你在每次请求时都调用无服务器函数。

1. 执行 getServerSideProps 的时间

    在 getServerSideProps 中的数据可用之前，页面生成不会开始。因此，我们必须确保 getServerSideProps 方法不会运行太长时间。

2. 在与无服务器功能相同的区域部署数据库

    如果数据来自数据库，我们必须减少查询数据库的时间。除了查询优化之外，你还应该考虑数据库的位置。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.38.55_PM_uwecig.webm"></video>

如果你的无服务器功能部署在旧金山，但你的数据库在东京，建立连接和获取数据可能需要一段时间。因此，请考虑将你的数据库移动到与无服务器功能相同的区域，以确保你的数据库查询更快地返回数据。

Vercel 使用无服务器功能来服务器渲染你的页面。

<img src="/img/patterns/2.30.png" loading=lazy>

尽管serverless function有很多好处，例如只需为你使用的东西付费，但也有一些限制。启动 lambda 所需的时间，称为长冷启动，是无服务器功能的常见问题。此外，与数据库的连接速度可能很慢。你也不应该从地球的另一侧调用位于地球一侧的无服务器函数。

# 边缘 SSR + HTTP 流

<img src="/img/patterns/2.31.png" loading=lazy>

Vercel 目前正在探索边缘服务器端渲染(Edge Server-Side Rendering——Edge SSR)，这将使用户能够从所有区域进行服务器渲染并体验近乎零的冷启动。
Edge SSR 的另一个好处是边缘运行时允许 HTTP 流式传输。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.47.07_PM_usqexj.webm"></video>

使用serverless function，我们在服务器端生成整个页面，并等待整个包在客户端加载和解析，然后才能开始注水。

<video preload autoplay style="width: 100%" playsinline controls loop src="https://res.cloudinary.com/dq8xfyhu4/video/upload/l_logo_pke9dv,o_52,x_-1510,y_-900/ac_none/v1609691928/CS%20Visualized/Screen_Recording_2022-05-05_at_5.48.20_PM_auurip.webm"></video>

借助 Edge SSR，我们可以在准备就绪后立即流式传输文档的各个部分，并细粒度地混合这些组件。这减少了用户的等待时间，因为他们可以在一个一个地流式传输时看到组件。

<img src="/img/patterns/2.32.png" loading=lazy>

Streaming SSR 还支持 React Server Components。Edge SSR 与 React Server Components 的结合可以让我们在静态和服务器渲染之间有一个漂亮的结合体。

React Server Components 允许我们在服务器上部分地渲染 React 组件，这对于需要下载大量依赖到客户端的的组件很有用。

<img src="/img/patterns/2.33.png" loading=lazy>

回到房地产网站的例子，如果我们想再次显示登陆页面并为用户包含特定区域的列表。
绝大多数页面只包含静态数据；它只是需要基于请求的数据的列表。

我们现在可以选择只在服务器端呈现列表组件，在客户端呈现其余部分，而不是必须在服务器端呈现整个页面。
虽然我们最初不得不通过服务器呈现整个页面来实现此行为，但现在我们可以获得静态呈现的出色性能以及服务器端呈现的动态优势。

# 结论

<img src="/img/patterns/2.34.png" loading=lazy>

我们现在已经引入了许多在服务器上渲染内容的模式。对于非常动态的网站，仍然建议使用完全再水合的客户端渲染 (CSR)，在这些网站中，屏幕上的每个组件都可能根据用户交互而改变。

根据应用程序或页面类型的类型，某些模式可能比其他模式更合适。下表比较了不同模式的亮点并提供了每种模式的用例。

<img src="/img/patterns/2.35.png" loading=lazy>

下表来自 [2022 年构建 JavaScript 网站的模式](https://dev.to/this-is-learning/patterns-for-building-javascript-websites-in-2022-5a93)，
提供了另一种以关键应用程序特征为中心的观点。它应该对任何正在为常见应用[程序最佳实践](https://jasonformat.com/application-holotypes/)寻找合适模式的人有所帮助。


[原文地址](https://www.patterns.dev/posts/rendering-introduction/)


